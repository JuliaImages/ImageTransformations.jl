<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package References · ImageTransformations</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageTransformations</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImageTransformations.jl</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Package References</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#High-level-API"><span>High-level API</span></a></li><li class="toplevel"><a class="tocitem" href="#Low-level-warping-API"><span>Low-level warping API</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Package References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="package_references"><a class="docs-heading-anchor" href="#package_references">Package References</a><a id="package_references-1"></a><a class="docs-heading-anchor-permalink" href="#package_references" title="Permalink"></a></h1><h1 id="High-level-API"><a class="docs-heading-anchor" href="#High-level-API">High-level API</a><a id="High-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ImageBase.restrict" href="#ImageBase.restrict"><code>ImageBase.restrict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restrict(img[, dims]) -&gt; imgr</code></pre><p>Reduce the size of <code>img</code> by approximately two-fold along the dimensions listed in <code>dims</code>, or all spatial coordinates if <code>dims</code> is not specified.</p><p><strong>Output</strong></p><p>The type of output array <code>imgr</code> depends on the input type:</p><ul><li>If <code>img</code> is an <code>OffsetArray</code>, then output array <code>imgr</code> will also be an <code>OffsetArray</code>.</li><li>If <code>img</code> is not an <code>OffsetArray</code>, then output array <code>imgr</code> will be an <code>Array</code> type even if it has offset indices.</li></ul><p>The size of <code>imgr</code> is approximately <code>1/2</code> of the original size. More specifically:</p><ul><li>if <code>Nₖ = size(img, k)</code> is odd, then <code>size(imgr, k) == (Nₖ+1) ÷ 2</code>.</li><li>if <code>Nₖ = size(img, k)</code> is even, then <code>size(imgr, k) == (Nₖ÷2) + 1</code>.</li></ul><p><strong>Examples</strong></p><p>The optional argument <code>dims</code> can be a <code>Tuple</code> or <code>Integer</code>:</p><pre><code class="language-julia hljs">A = rand(5, 5) # size: (5, 5)

restrict(A) # size: (3, 3)

restrict(A, 1) # size: (3, 5)
restrict(A, 2) # size: (5, 3)

restrict(A, (1, )) # size: (3, 5)
restrict(A, (1, 2)) # size: (3, 3)</code></pre><p>Unless the input array is 1-based, the origin will be halfed:</p><pre><code class="language-julia hljs">julia&gt; using ImageBase, OffsetArrays

julia&gt; Ao = OffsetArray(rand(5, 4), 5, 6);

julia&gt; Ar = restrict(Ao);

julia&gt; axes(Ao)
(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))

julia&gt; axes(Ar)
(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))</code></pre><p><strong>Extended help</strong></p><p>The term <code>restrict</code> is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of &quot;prolongation&quot; (which is essentially interpolation). <code>restrict</code> anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of <code>restrict</code> has been tuned for performance, and should be a fast method for constructing <a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing)">pyramids</a>.</p><p>If <code>l</code> is the size of <code>img</code> along a particular dimension, <code>restrict</code> produces an array of size <code>(l+1)÷2</code> for odd <code>l</code>, and <code>l÷2 + 1</code> for even <code>l</code>. See the example below for an explanation.</p><p>See also <a href="@ref"><code>imresize</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a_course = [0, 1, 0.3]</code></pre><p>If we were to interpolate this at the halfway points, we&#39;d get</p><pre><code class="language-julia hljs">a_fine = [0, 0.5, 1, 0.65, 0.3]</code></pre><p>Note that <code>a_fine</code> is obtained from <code>a_course</code> via the <em>prolongation</em> operator <code>P</code> as <code>P*a_course</code>, where</p><pre><code class="language-julia hljs">P = [1   0   0;      # this line &quot;copies over&quot; the first point
     0.5 0.5 0;      # this line takes the mean of the first and second point
     0   1   0;      # copy the second point
     0   0.5 0.5;    # take the mean of the second and third
     0   0   1]      # copy the third</code></pre><p><code>restrict</code> is the adjoint of prolongation. Consequently,</p><pre><code class="language-julia hljs">julia&gt; restrict(a_fine)
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125

julia&gt; (P&#39;*a_fine)/2
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125</code></pre><p>where the division by 2 approximately preserves the mean intensity of the input.</p><p>As we see here, for odd-length <code>a_fine</code>, restriction is the adjoint of interpolation at half-grid points. When <code>length(a_fine)</code> is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the <code>l-&gt;l÷2 + 1</code> behavior.</p><p>One consequence of this definition is that the edges move towards zero:</p><pre><code class="language-julia hljs">julia&gt; restrict(ones(11))
6-element Array{Float64,1}:
 0.75
 1.0
 1.0
 1.0
 1.0
 0.75</code></pre><p>In some applications (e.g., image registration), you may find it useful to trim the edges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.imrotate" href="#ImageTransformations.imrotate"><code>ImageTransformations.imrotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imrotate(img, θ, [indices], [degree = Linear()], [fill = NaN]) -&gt; imgr</code></pre><p>Rotate image <code>img</code> by <code>θ</code>∈[0,2π) in a clockwise direction around its center point. To rotate the image counterclockwise, specify a negative value for angle.</p><p>By default, rotated image <code>imgr</code> will not be cropped. Bilinear interpolation will be used and values outside the image are filled with <code>NaN</code> if possible, otherwise with <code>0</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; img = testimage(&quot;cameraman&quot;)

# rotate with bilinear interpolation but without cropping
julia&gt; imrotate(img, π/4)

# rotate with bilinear interpolation and with cropping
julia&gt; imrotate(img, π/4, axes(img))

# rotate with nearest interpolation but without cropping
julia&gt; imrotate(img, π/4, Constant())

The keyword `method` now also takes any InterpolationType from Interpolations.jl
or a Degree, which is used to define a BSpline interpolation of that degree, in
order to set the interpolation method used during image rotation.
</code></pre><p>julia</p><p><strong>rotate with Linear interpolation without cropping</strong></p><p>julia&gt; imrotate(img, π/4, method = Linear())</p><p><strong>rotate with Lanczos4OpenCV interpolation without cropping</strong></p><p>julia&gt; imrotate(img, π/4, method = Lanczos4OpenCV()) ```</p><p>See also <a href="#ImageTransformations.warp"><code>warp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/warp.jl#L120-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.imresize" href="#ImageTransformations.imresize"><code>ImageTransformations.imresize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imresize(img, sz) -&gt; imgr
imresize(img, inds) -&gt; imgr
imresize(img; ratio) -&gt; imgr</code></pre><p>Change <code>img</code> to be of size <code>sz</code> (or to have indices <code>inds</code>). If <code>ratio</code> is used, then <code>sz = ceil(Int, size(img).*ratio)</code>. This interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter <code>img</code> first.</p><p>The keyword <code>method</code> takes any InterpolationType from Interpolations.jl or a Degree, which is used to define a BSpline interpolation of that degree, in order to set the interpolation method used in the image resizing.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; img = testimage(&quot;lena_gray_256&quot;) # 256*256
julia&gt; imresize(img, 128, 128) # 128*128
julia&gt; imresize(img, 1:128, 1:128) # 128*128
julia&gt; imresize(img, (128, 128)) # 128*128
julia&gt; imresize(img, (1:128, 1:128)) # 128*128
julia&gt; imresize(img, (1:128, )) # 128*256
julia&gt; imresize(img, 128) # 128*256
julia&gt; imresize(img, ratio = 0.5) #128*128
julia&gt; imresize(img, ratio = (2, 1)) # 256*128
julia&gt; imresize(img, (128,128), method=Linear()) #128*128
julia&gt; imresize(img, (128,128), method=BSpline(Linear())) #128*128
julia&gt; imresize(img, (128,128), method=Lanczos4OpenCV()) #128*128

σ = map((o,n)-&gt;0.75*o/n, size(img), sz)
kern = KernelFactors.gaussian(σ)   # from ImageFiltering
imgr = imresize(imfilter(img, kern, NA()), sz)</code></pre><p>See also <a href="@ref"><code>restrict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/resizing.jl#L252-L286">source</a></section></article><h1 id="Low-level-warping-API"><a class="docs-heading-anchor" href="#Low-level-warping-API">Low-level warping API</a><a id="Low-level-warping-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-warping-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.warp" href="#ImageTransformations.warp"><code>ImageTransformations.warp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">warp(img, tform, [indices], [degree = Linear()], [fill = NaN]) -&gt; imgw</code></pre><p>Transform the coordinates of <code>img</code>, returning a new <code>imgw</code> satisfying <code>imgw[I] = img[tform(I)]</code>. This approach is known as backward mode warping. The transformation <code>tform</code> must accept a <code>SVector</code> as input. A useful package to create a wide variety of such transformations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</p><p><strong>Reconstruction scheme</strong></p><p>During warping, values for <code>img</code> must be reconstructed at arbitrary locations <code>tform(I)</code> which do not lie on to the lattice of pixels. How this reconstruction is done depends on the type of <code>img</code> and the optional parameter <code>degree</code>.</p><p>When <code>img</code> is a plain array, then on-grid b-spline interpolation will be used. It is possible to configure what degree of b-spline to use with the parameter <code>degree</code>. For example one can use <code>degree = Linear()</code> for linear interpolation, <code>degree = Constant()</code> for nearest neighbor interpolation, or <code>degree = Quadratic(Flat())</code> for quadratic interpolation.</p><p>In the case <code>tform(I)</code> maps to indices outside the original <code>img</code>, those locations are set to a value <code>fill</code> (which defaults to <code>NaN</code> if the element type supports it, and <code>0</code> otherwise). The parameter <code>fill</code> also accepts extrapolation schemes, such as <code>Flat()</code>, <code>Periodic()</code> or <code>Reflect()</code>.</p><p>For more control over the reconstruction scheme –- and how beyond-the-edge points are handled –- pass <code>img</code> as an <code>AbstractInterpolation</code> or <code>AbstractExtrapolation</code> from <a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations.jl</a>.</p><p>The keyword <code>method</code> now also takes any InterpolationType from Interpolations.jl or a Degree, which is used to define a BSpline interpolation of that degree, in order to set the interpolation method used.</p><p><strong>The meaning of the coordinates</strong></p><p>The output array <code>imgw</code> has indices that would result from applying <code>inv(tform)</code> to the indices of <code>img</code>. This can be very handy for keeping track of how pixels in <code>imgw</code> line up with pixels in <code>img</code>.</p><p>If you just want a plain array, you can &quot;strip&quot; the custom indices with <code>parent(imgw)</code>.</p><p><strong>Examples: a 2d rotation (see JuliaImages documentation for pictures)</strong></p><pre><code class="nohighlight hljs">julia&gt; using Images, CoordinateTransformations, Rotations, TestImages, OffsetArrays

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; axes(img)
(Base.OneTo(512),Base.OneTo(768))

# Rotate around the center of `img`
julia&gt; tfm = recenter(RotMatrix(-pi/4), center(img))
AffineMap([0.707107 0.707107; -0.707107 0.707107], [-196.755,293.99])

julia&gt; imgw = warp(img, tfm);

julia&gt; axes(imgw)
(-196:709,-68:837)

# Alternatively, specify the origin in the image itself
julia&gt; img0 = OffsetArray(img, -30:481, -384:383);  # origin near top of image

julia&gt; rot = LinearMap(RotMatrix(-pi/4))
LinearMap([0.707107 -0.707107; 0.707107 0.707107])

julia&gt; imgw = warp(img0, rot);

julia&gt; axes(imgw)
(-293:612,-293:611)

julia&gt; imgr = parent(imgw);
</code></pre><p>jldoctest using ImageTransformations, CoordinateTransformations, Rotations, TestImages, OffsetArrays using OffsetArrays: IdOffsetRange img = testimage(&quot;lighthouse&quot;) # axes (1:512, 1:768)</p><p>tfm = recenter(RotMatrix(-pi/4), center(img)) imgw = warp(img, tfm)</p><p>axes(imgw)</p><p><strong>output</strong></p><p>(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837)) ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/warp.jl#L1-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.WarpedView" href="#ImageTransformations.WarpedView"><code>ImageTransformations.WarpedView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WarpedView(img, tform, [indices]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[tform(I)]</code>. This approach is known as backward mode warping.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>. To do this <code>inv(tform)</code> has to be computed. If the given transformation <code>tform</code> does not support <code>inv</code>, then the parameter <code>indices</code> has to be specified manually.</p><p>see <a href="@ref"><code>warpedview</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/warpedview.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.InvWarpedView" href="#ImageTransformations.InvWarpedView"><code>ImageTransformations.InvWarpedView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InvWarpedView(img, tinv, [indices]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[inv(tinv)(I)]</code>. While technically this approach is known as backward mode warping, note that <code>InvWarpedView</code> is created by supplying the forward transformation</p><p>The conceptual difference to <a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> is that <code>InvWarpedView</code> is intended to be used when reasoning about the image is more convenient that reasoning about the indices. Furthermore, <code>InvWarpedView</code> allows simple nesting of transformations, in which case the transformations will be composed into a single one.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>.</p><p>see <a href="#ImageTransformations.invwarpedview"><code>invwarpedview</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/invwarpedview.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.invwarpedview" href="#ImageTransformations.invwarpedview"><code>ImageTransformations.invwarpedview</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invwarpedview(img, tinv, [indices], [degree = Linear()], [fill = NaN]) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> to correspond to <code>img[inv(tinv)(I)]</code>. While technically this approach is known as backward mode warping, note that <code>InvWarpedView</code> is created by supplying the forward transformation. The given transformation <code>tinv</code> must accept a <code>SVector</code> as input and support <code>inv(tinv)</code>. A useful package to create a wide variety of such transformations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</p><p>When invoking <code>wv[I]</code>, values for <code>img</code> must be reconstructed at arbitrary locations <code>inv(tinv)(I)</code>. <code>InvWarpedView</code> serves as a wrapper around <a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> which takes care of interpolation and extrapolation. The parameters <code>degree</code> and <code>fill</code> can be used to specify the b-spline degree and the extrapolation scheme respectively.</p><p>The optional parameter <code>indices</code> can be used to specify the domain of the resulting <code>wv</code>. By default the indices are computed in such a way that <code>wv</code> contains all the original pixels in <code>img</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/fcfa88d4d5c70f773133c13e4a397ecc987f812c/src/invwarpedview.jl#L69-L92">source</a></section></article><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>ImageTransformations.autorange</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Sunday 1 August 2021 15:51">Sunday 1 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
