<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package References · ImageTransformations</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageTransformations</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImageTransformations.jl</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Package References</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#High-level-API"><span>High-level API</span></a></li><li class="toplevel"><a class="tocitem" href="#Low-level-warping-API"><span>Low-level warping API</span></a></li><li class="toplevel"><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Package References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="package_references"><a class="docs-heading-anchor" href="#package_references">Package References</a><a id="package_references-1"></a><a class="docs-heading-anchor-permalink" href="#package_references" title="Permalink"></a></h1><h1 id="High-level-API"><a class="docs-heading-anchor" href="#High-level-API">High-level API</a><a id="High-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ImageBase.restrict" href="#ImageBase.restrict"><code>ImageBase.restrict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restrict(img[, dims]) -&gt; imgr</code></pre><p>Reduce the size of <code>img</code> by approximately two-fold along the dimensions listed in <code>dims</code>, or all spatial coordinates if <code>dims</code> is not specified.</p><p><strong>Output</strong></p><p>The type of output array <code>imgr</code> depends on the input type:</p><ul><li>If <code>img</code> is an <code>OffsetArray</code>, then output array <code>imgr</code> will also be an <code>OffsetArray</code>.</li><li>If <code>img</code> is not an <code>OffsetArray</code>, then output array <code>imgr</code> will be an <code>Array</code> type even if it has offset indices.</li></ul><p>The size of <code>imgr</code> is approximately <code>1/2</code> of the original size. More specifically:</p><ul><li>if <code>Nₖ = size(img, k)</code> is odd, then <code>size(imgr, k) == (Nₖ+1) ÷ 2</code>.</li><li>if <code>Nₖ = size(img, k)</code> is even, then <code>size(imgr, k) == (Nₖ÷2) + 1</code>.</li></ul><p><strong>Examples</strong></p><p>The optional argument <code>dims</code> can be a <code>Tuple</code> or <code>Integer</code>:</p><pre><code class="language-julia hljs">A = rand(5, 5) # size: (5, 5)

restrict(A) # size: (3, 3)

restrict(A, 1) # size: (3, 5)
restrict(A, 2) # size: (5, 3)

restrict(A, (1, )) # size: (3, 5)
restrict(A, (1, 2)) # size: (3, 3)</code></pre><p>Unless the input array is 1-based, the origin will be halfed:</p><pre><code class="language-julia hljs">julia&gt; using ImageBase, OffsetArrays

julia&gt; Ao = OffsetArray(rand(5, 4), 5, 6);

julia&gt; Ar = restrict(Ao);

julia&gt; axes(Ao)
(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))

julia&gt; axes(Ar)
(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))</code></pre><p><strong>Extended help</strong></p><p>The term <code>restrict</code> is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of &quot;prolongation&quot; (which is essentially interpolation). <code>restrict</code> anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of <code>restrict</code> has been tuned for performance, and should be a fast method for constructing <a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing)">pyramids</a>.</p><p>If <code>l</code> is the size of <code>img</code> along a particular dimension, <code>restrict</code> produces an array of size <code>(l+1)÷2</code> for odd <code>l</code>, and <code>l÷2 + 1</code> for even <code>l</code>. See the example below for an explanation.</p><p>See also <code>ImageTransformations.imresize</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">a_course = [0, 1, 0.3]</code></pre><p>If we were to interpolate this at the halfway points, we&#39;d get</p><pre><code class="language-julia hljs">a_fine = [0, 0.5, 1, 0.65, 0.3]</code></pre><p>Note that <code>a_fine</code> is obtained from <code>a_course</code> via the <em>prolongation</em> operator <code>P</code> as <code>P*a_course</code>, where</p><pre><code class="language-julia hljs">P = [1   0   0;      # this line &quot;copies over&quot; the first point
     0.5 0.5 0;      # this line takes the mean of the first and second point
     0   1   0;      # copy the second point
     0   0.5 0.5;    # take the mean of the second and third
     0   0   1]      # copy the third</code></pre><p><code>restrict</code> is the adjoint of prolongation. Consequently,</p><pre><code class="language-julia hljs">julia&gt; restrict(a_fine)
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125

julia&gt; (P&#39;*a_fine)/2
3-element Array{Float64,1}:
 0.125
 0.7875
 0.3125</code></pre><p>where the division by 2 approximately preserves the mean intensity of the input.</p><p>As we see here, for odd-length <code>a_fine</code>, restriction is the adjoint of interpolation at half-grid points. When <code>length(a_fine)</code> is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the <code>l-&gt;l÷2 + 1</code> behavior.</p><p>One consequence of this definition is that the edges move towards zero:</p><pre><code class="language-julia hljs">julia&gt; restrict(ones(11))
6-element Array{Float64,1}:
 0.75
 1.0
 1.0
 1.0
 1.0
 0.75</code></pre><p>In some applications (e.g., image registration), you may find it useful to trim the edges.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.imrotate" href="#ImageTransformations.imrotate"><code>ImageTransformations.imrotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imrotate(img, θ, [indices]; kwargs...) -&gt; imgr</code></pre><p>Rotate image <code>img</code> by <code>θ</code>∈[0,2π) in a clockwise direction around its center point.</p><p><strong>Arguments</strong></p><ul><li><code>img::AbstractArray</code>: the original image that you need to rotate.</li><li><code>θ::Real</code>: the rotation angle in clockwise direction. To rotate the image in conter-clockwise direction, use a negative value instead. To rotate the image by <code>d</code> degree, use the formular <code>θ=d*π/180</code>.</li><li><code>indices</code> (Optional): specifies the output image axes. By default, rotated image <code>imgr</code> will not be cropped, and thus <code>axes(imgr) == axes(img)</code> does not hold in general.</li></ul><p><strong>Parameters</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To construct <code>method</code> and <code>fillvalue</code> values, you may need to load <code>Interpolations</code> package first.</p></div></div><ul><li><code>method::Union{Degree, InterpolationType}</code>: the interpolation method you want to use. By default it is <code>Linear()</code>.</li><li><code>fillvalue</code>: the value that used to fill the new region. The default value is <code>NaN</code> if possible, otherwise is <code>0</code>.</li></ul><p>This function is a simple high-level interface to <code>warp</code>, for more explaination and details, please refer to <a href="#ImageTransformations.warp"><code>warp</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using TestImages, ImageTransformations
img = testimage(&quot;cameraman&quot;)

# Rotate the image by π/4 in the clockwise direction
imgr = imrotate(img, π/4) # output axes (-105:618, -105:618)

# Rotate the image by π/4 in the counter-clockwise direction
imgr = imrotate(img, -π/4) # output axes (-105:618, -105:618)

# Preserve the original axes
# Note that this is more efficient than `@view imrotate(img, π/4)[axes(img)...]`
imgr = imrotate(img, π/4, axes(img)) # output axes (1:512, 1:512)</code></pre><p>By default, <code>imrotate</code> uses bilinear interpolation with constant fill value (<code>NaN</code> or <code>0</code>). You can, for example, use the nearest interpolation and fill the new region with white pixels:</p><pre><code class="language-julia hljs">using Interpolations, ImageCore
imrotate(img, π/4, method=Constant(), fillvalue=oneunit(eltype(img)))</code></pre><p>And with some inspiration, maybe fill with periodic values and tile the output together to get a mosaic:</p><pre><code class="language-julia hljs">using Interpolations, ImageCore
imgr = imrotate(img, π/4, fillvalue = Periodic())
mosaicview([imgr for _ in 1:9]; nrow=3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/warp.jl#L186-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.imresize" href="#ImageTransformations.imresize"><code>ImageTransformations.imresize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">imresize(img, sz; [method]) -&gt; imgr
imresize(img, inds; [method]) -&gt; imgr
imresize(img; ratio, [method]) -&gt; imgr</code></pre><p>upsample/downsample the image <code>img</code> to a given size <code>sz</code> or axes <code>inds</code> using interpolations. If <code>ratio</code> is provided, the output size is then <code>ceil(Int, size(img).*ratio)</code>.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter <code>img</code> first.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>img</code>: the input image array</li><li><code>sz</code>: the size of output array</li><li><code>inds</code>: the axes of output array If <code>inds</code> is passed, the output array <code>imgr</code> will be <code>OffsetArray</code>.</li></ul><p><strong>Parameters</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To construct <code>method</code>, you may need to load <code>Interpolations</code> package first.</p></div></div><ul><li><code>ratio</code>: the upsample/downsample ratio used. The output size is <code>ceil(Int, size(img).*ratio)</code>. If <code>ratio</code> is larger than <code>1</code>, it is an upsample operation. Otherwise it is a downsample operation. <code>ratio</code> can also be a tuple, in which case <code>ratio[i]</code> specifies the resize ratio at dimension <code>i</code>.</li><li><code>method::InterpolationType</code>:  specify the interpolation method used for reconstruction. conveniently, <code>methold</code> can also be a <code>Degree</code> type, in which case a <code>BSpline</code> object will be created. For example, <code>method = Linear()</code> is equivalent to <code>method = BSpline(Linear())</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ImageTransformations, TestImages, Interpolations

img = testimage(&quot;lighthouse&quot;) # 512*768

# pass integers as size
imresize(img, 256, 384) # 256*384
imresize(img, (256, 384)) # 256*384
imresize(img, 256) # 256*768

# pass indices as axes
imresize(img, 1:256, 1:384) # 256*384
imresize(img, (1:256, 1:384)) # 256*384
imresize(img, (1:256, )) # 256*768

# pass resize ratio
imresize(img, ratio = 0.5) #256*384
imresize(img, ratio = (2, 1)) # 1024*768

# use different interpolation method
imresize(img, (256, 384), method=Linear()) # 256*384 bilinear interpolation
imresize(img, (256, 384), method=Lanczos4OpenCV()) # 256*384 OpenCV-compatible Lanczos 4 interpolation</code></pre><p>For downsample with <code>ratio=0.5</code>, <a href="#ImageBase.restrict"><code>restrict</code></a> is a much faster two-fold implementation that you can use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/resizing.jl#L32-L93">source</a></section></article><h1 id="Low-level-warping-API"><a class="docs-heading-anchor" href="#Low-level-warping-API">Low-level warping API</a><a id="Low-level-warping-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-warping-API" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.warp" href="#ImageTransformations.warp"><code>ImageTransformations.warp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">warp(img, tform, [indices]; kwargs...) -&gt; imgw</code></pre><p>Transform the coordinates of <code>img</code>, returning a new <code>imgw</code> satisfying <code>imgw[I] = img[tform(I)]</code>.</p><p><strong>Output</strong></p><p>The output array <code>imgw</code> is an <code>OffsetArray</code>. Unless manually specified, <code>axes(imgw) == axes(img)</code> does not hold in general. If you just want a plain array, you can &quot;strip&quot; the custom indices with <code>parent(imgw)</code> or <code>OffsetArrays.no_offset_view(imgw)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>img</code>: the original image that you need coordinate transformation.</li><li><code>tform</code>: the coordinate transformation function or function-like object, it must accept a <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>SVector</code></a> as input. A useful package to create a wide variety of such transfomrations is <a href="https://github.com/FugroRoames/CoordinateTransformations.jl">CoordinateTransformations.jl</a>.</li><li><code>indices</code> (Optional): specifies the output image axes. By default, the indices are computed in such a way that <code>imgw</code> contains all the original pixels in <code>img</code> using <a href="#ImageTransformations.autorange"><code>autorange</code></a>. To do this <code>inv(tform)</code> has to be computed. If the given transfomration <code>tform</code> does not support <code>inv</code> then the parameter <code>indices</code> has to be specified manually.</li></ul><p><strong>Parameters</strong></p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>To construct <code>method</code> and <code>fillvalue</code> values, you may need to load <code>Interpolations</code> package first.</p></div></div><ul><li><code>method::Union{Degree, InterpolationType}</code>: the interpolation method you want to use. By default it is <code>BSpline(Linear())</code>. To construct the method instance, one may need to load <code>Interpolations</code>.</li><li><code>fillvalue</code>: the value that used to fill the new region. The default value is <code>NaN</code> if possible, otherwise is <code>0</code>. One can also pass the extrapolation boundary condition: <code>Flat()</code>, <code>Reflect()</code> and <code>Periodic()</code>.</li></ul><p><strong>See also</strong></p><p>There&#39;re some high-level interfaces of <code>warp</code>:</p><ul><li>image rotation: <a href="#ImageTransformations.imrotate"><code>imrotate</code></a></li><li>image resize: <a href="#ImageTransformations.imresize"><code>imresize</code></a></li></ul><p>There are also lazy versions of <code>warp</code>:</p><ul><li><a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> is almost equivalent to <code>warp</code> except that it does not allocate memory.</li><li><a href="#ImageTransformations.InvWarpedView"><code>InvWarpedView(img, tform, [indices]; kwargs...)</code></a> is almost equivalent to <code>warp(img, inv(tform), [indices]; kwargs...)</code> except that it does not allocate memory.</li></ul><p><strong>Extended help</strong></p><p><strong>Parameters in detail</strong></p><p>This approach is known as backward mode warping. It is called &quot;backward&quot; because the internal coordinate transformation is actually an inverse map from <code>axes(imgr)</code> to <code>axes(img)</code>.</p><p>You can manually specify interpolation behavior by constructing <code>AbstractExtrapolation</code> object and passing it to <code>warp</code> as <code>img</code>. However, this is usually cumbersome. For this reason, there are two keywords <code>method</code> and <code>fillvalue</code> to conveniently construct an <code>AbstractExtrapolation</code> object during <code>warp</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If <code>img</code> is an <code>AbstractExtrapolation</code>, then additional <code>method</code> and <code>fillvalue</code> keywords will be discarded.</p></div></div><p><strong><code>method::Union{Degree, InterpolationType}</code></strong></p><p>The interpolation method you want to use to reconstruct values in the wrapped image.</p><p>Among those possible <code>InterpolationType</code> choice, there are some commonly used methods that you may have used in other languages:</p><ul><li>nearest neighbor: <code>BSpline(Constant())</code></li><li>triangle/bilinear: <code>BSpline(Linear())</code></li><li>bicubic: <code>BSpline(Cubic(Line(OnGrid())))</code></li><li>lanczos2: <code>Lanczos(2)</code></li><li>lanczos3: <code>Lanczos(3)</code></li><li>lanczos4: <code>Lanczos(4)</code> or <code>Lanczos4OpenCV()</code></li></ul><p>When passing a <code>Degree</code>, it is expected to be a <code>BSpline</code>. For example, <code>Linear()</code> is equivalent to <code>BSpline(Linear())</code>.</p><p><strong><code>fillvalue</code></strong></p><p>In case <code>tform(I)</code> maps to indices outside the original <code>img</code>, those locations are set to a value <code>fillvalue</code>. The default fillvalue is <code>NaN</code> if the element type of <code>img</code> supports it, and <code>0</code> otherwise.</p><p>The parameter <code>fillvalue</code> can be either a <code>Number</code> or <code>Colorant</code>. In this case, it will be converted to <code>eltype(imgr)</code> first. For example, <code>fillvalue = 1</code> will be converted to <code>Gray(1)</code> which will fill the outside indices with white pixels.</p><p>Also, <code>fillvalue</code> can be extrapolation schemes: <code>Flat()</code>, <code>Periodic()</code> and <code>Reflect()</code>. The best way to understand these schemes is perhaps try it with small example:</p><pre><code class="language-julia-repl hljs">julia&gt; using ImageTransformations, TestImages, Interpolations

julia&gt; using OffsetArrays: IdOffsetRange

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; imgr = imrotate(img, π/4; fillvalue=Flat()); # zero extrapolation slope

julia&gt; imgr = imrotate(img, π/4; fillvalue=Periodic()); # periodic boundary

julia&gt; imgr = imrotate(img, π/4; fillvalue=Reflect()); # mirror boundary

julia&gt; axes(imgr)
(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837))</code></pre><p><strong>The meaning of the coordinates</strong></p><p><code>imgw</code> keeps track of the indices that would result from applying <code>inv(tform)</code> to the indices of <code>img</code>. This can be very handy for keeping track of how pixels in <code>imgw</code> line up with pixels in <code>img</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using ImageTransformations, TestImages, Interpolations

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; imgr = imrotate(img, π/4);

julia&gt; imgr_cropped = imrotate(img, π/4, axes(img));

julia&gt; imgr[axes(img)...] == imgr_cropped # No need to manually calculate the offsets
true</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For performance consideration, it&#39;s recommended to pass the <code>inds</code> positional argument to <code>warp</code> instead of cropping the output with <code>imgw[inds...]</code>.</p></div></div><p><strong>Examples: a 2d rotation</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This example only shows how to construct <code>tform</code> and calls <code>warp</code>. For common usage, it is recommended to use <a href="#ImageTransformations.imrotate"><code>imrotate</code></a> function directly.</p></div></div><p>Rotate around the center of <code>img</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using ImageTransformations, CoordinateTransformations, Rotations, TestImages, OffsetArrays

julia&gt; using OffsetArrays: IdOffsetRange

julia&gt; img = testimage(&quot;lighthouse&quot;);

julia&gt; axes(img)
(Base.OneTo(512), Base.OneTo(768))

julia&gt; tfm = recenter(RotMatrix(-pi/4), center(img));

julia&gt; imgw = warp(img, tfm);

julia&gt; axes(imgw)
(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/warp.jl#L1-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.WarpedView" href="#ImageTransformations.WarpedView"><code>ImageTransformations.WarpedView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WarpedView(img, tform, [indices]; kwargs...) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> so that <code>wv[I] == img[tform(I)]</code>.</p><p>This is the lazy view version of <code>warp</code>, please see <a href="#ImageTransformations.warp"><code>warp</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/warpedview.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.InvWarpedView" href="#ImageTransformations.InvWarpedView"><code>ImageTransformations.InvWarpedView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InvWarpedView(img, tinv, [indices]; kwargs...) -&gt; wv
InvWarpedView(inner_view, tinv) -&gt; wv</code></pre><p>Create a view of <code>img</code> that lazily transforms any given index <code>I</code> passed to <code>wv[I]</code> so that <code>wv[I] == img[inv(tinv)(I)]</code>.</p><p>Except for the lazy evaluation, the following two lines are expected to be equivalent:</p><pre><code class="language-julia hljs">warp(img, inv(tform), [indices]; kwargs...)
invwarpedview(img, tform, [indices]; kwargs...)</code></pre><p>The conceptual difference to <a href="#ImageTransformations.WarpedView"><code>WarpedView</code></a> is that <code>InvWarpedView</code> is intended to be used when reasoning about the image is more convenient that reasoning about the indices. Furthermore, <code>InvWarpedView</code> allows simple nesting of transformations, in which case the transformations will be composed into a single one.</p><p>For detailed explaination of warp, associated arguments and parameters, please refer to <a href="#ImageTransformations.warp"><code>warp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/invwarpedview.jl#L1-L24">source</a></section></article><h1 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ImageTransformations.autorange" href="#ImageTransformations.autorange"><code>ImageTransformations.autorange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">autorange(A::AbstractArray, tform::Transformation)</code></pre><p>For given transformation <code>tform</code>, return the &quot;smallest&quot; range indices that preserves all information from <code>A</code> after applying <code>tform</code>.</p><p><strong>Examples</strong></p><p>For transformation that preserves the array size, <code>autorange</code> is equivalent to <code>axes(A)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(5, 5);

julia&gt; tform = IdentityTransformation();

julia&gt; autorange(A, tform) == axes(A)
true</code></pre><p>The diffrence shows up when <code>tform</code> enlarges the input array <code>A</code>. In the following example, we need at least <code>(0:6, 0:6)</code> as the range indices to get all data of <code>A</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(5, 5);

julia&gt; tform = recenter(RotMatrix(pi/8), center(A));

julia&gt; autorange(A, tform)
(0:6, 0:6)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function is not exported; it is mainly for internal usage to infer the default indices.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageTransformations.jl/blob/41d3f9687094fa9d0093a12097df9a083de1f46a/src/autorange.jl#L1-L34">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 20 May 2025 01:29">Tuesday 20 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
