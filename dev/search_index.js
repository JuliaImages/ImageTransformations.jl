var documenterSearchIndex = {"docs":
[{"location":"reference/#package_references","page":"Package References","title":"Package References","text":"","category":"section"},{"location":"reference/#High-level-API","page":"Package References","title":"High-level API","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageBase.restrict\nImageTransformations.imrotate\nImageTransformations.imresize","category":"page"},{"location":"reference/#ImageBase.restrict","page":"Package References","title":"ImageBase.restrict","text":"restrict(img[, dims]) -> imgr\n\nReduce the size of img by approximately two-fold along the dimensions listed in dims, or all spatial coordinates if dims is not specified.\n\nOutput\n\nThe type of output array imgr depends on the input type:\n\nIf img is an OffsetArray, then output array imgr will also be an OffsetArray.\nIf img is not an OffsetArray, then output array imgr will be an Array type even if it has offset indices.\n\nThe size of imgr is approximately 1/2 of the original size. More specifically:\n\nif Nₖ = size(img, k) is odd, then size(imgr, k) == (Nₖ+1) ÷ 2.\nif Nₖ = size(img, k) is even, then size(imgr, k) == (Nₖ÷2) + 1.\n\nExamples\n\nThe optional argument dims can be a Tuple or Integer:\n\nA = rand(5, 5) # size: (5, 5)\n\nrestrict(A) # size: (3, 3)\n\nrestrict(A, 1) # size: (3, 5)\nrestrict(A, 2) # size: (5, 3)\n\nrestrict(A, (1, )) # size: (3, 5)\nrestrict(A, (1, 2)) # size: (3, 3)\n\nUnless the input array is 1-based, the origin will be halfed:\n\njulia> using ImageBase, OffsetArrays\n\njulia> Ao = OffsetArray(rand(5, 4), 5, 6);\n\njulia> Ar = restrict(Ao);\n\njulia> axes(Ao)\n(OffsetArrays.IdOffsetRange(values=6:10, indices=6:10), OffsetArrays.IdOffsetRange(values=7:10, indices=7:10))\n\njulia> axes(Ar)\n(OffsetArrays.IdOffsetRange(values=3:5, indices=3:5), OffsetArrays.IdOffsetRange(values=4:6, indices=4:6))\n\nExtended help\n\nThe term restrict is taken from the coarsening operation of algebraic multigrid methods; it is the adjoint of \"prolongation\" (which is essentially interpolation). restrict anti-aliases the image as it goes, so is better than a naive summation over 2x2 blocks. The implementation of restrict has been tuned for performance, and should be a fast method for constructing pyramids.\n\nIf l is the size of img along a particular dimension, restrict produces an array of size (l+1)÷2 for odd l, and l÷2 + 1 for even l. See the example below for an explanation.\n\nSee also ImageTransformations.imresize.\n\nExample\n\na_course = [0, 1, 0.3]\n\nIf we were to interpolate this at the halfway points, we'd get\n\na_fine = [0, 0.5, 1, 0.65, 0.3]\n\nNote that a_fine is obtained from a_course via the prolongation operator P as P*a_course, where\n\nP = [1   0   0;      # this line \"copies over\" the first point\n     0.5 0.5 0;      # this line takes the mean of the first and second point\n     0   1   0;      # copy the second point\n     0   0.5 0.5;    # take the mean of the second and third\n     0   0   1]      # copy the third\n\nrestrict is the adjoint of prolongation. Consequently,\n\njulia> restrict(a_fine)\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\njulia> (P'*a_fine)/2\n3-element Array{Float64,1}:\n 0.125\n 0.7875\n 0.3125\n\nwhere the division by 2 approximately preserves the mean intensity of the input.\n\nAs we see here, for odd-length a_fine, restriction is the adjoint of interpolation at half-grid points. When length(a_fine) is even, restriction is the adjoint of interpolation at 1/4 and 3/4-grid points. This turns out to be the origin of the l->l÷2 + 1 behavior.\n\nOne consequence of this definition is that the edges move towards zero:\n\njulia> restrict(ones(11))\n6-element Array{Float64,1}:\n 0.75\n 1.0\n 1.0\n 1.0\n 1.0\n 0.75\n\nIn some applications (e.g., image registration), you may find it useful to trim the edges.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.imrotate","page":"Package References","title":"ImageTransformations.imrotate","text":"imrotate(img, θ, [indices]; kwargs...) -> imgr\n\nRotate image img by θ∈[0,2π) in a clockwise direction around its center point.\n\nArguments\n\nimg::AbstractArray: the original image that you need to rotate.\nθ::Real: the rotation angle in clockwise direction. To rotate the image in conter-clockwise direction, use a negative value instead. To rotate the image by d degree, use the formular θ=d*π/180.\nindices (Optional): specifies the output image axes. By default, rotated image imgr will not be cropped, and thus axes(imgr) == axes(img) does not hold in general.\n\nParameters\n\ninfo: Info\nTo construct method and fillvalue values, you may need to load Interpolations package first.\n\nmethod::Union{Degree, InterpolationType}: the interpolation method you want to use. By default it is Linear().\nfillvalue: the value that used to fill the new region. The default value is NaN if possible, otherwise is 0.\n\nThis function is a simple high-level interface to warp, for more explaination and details, please refer to warp.\n\nExamples\n\nusing TestImages, ImageTransformations\nimg = testimage(\"cameraman\")\n\n# Rotate the image by π/4 in the clockwise direction\nimgr = imrotate(img, π/4) # output axes (-105:618, -105:618)\n\n# Rotate the image by π/4 in the counter-clockwise direction\nimgr = imrotate(img, -π/4) # output axes (-105:618, -105:618)\n\n# Preserve the original axes\n# Note that this is more efficient than `@view imrotate(img, π/4)[axes(img)...]`\nimgr = imrotate(img, π/4, axes(img)) # output axes (1:512, 1:512)\n\nBy default, imrotate uses bilinear interpolation with constant fill value (NaN or 0). You can, for example, use the nearest interpolation and fill the new region with white pixels:\n\nusing Interpolations, ImageCore\nimrotate(img, π/4, method=Constant(), fillvalue=oneunit(eltype(img)))\n\nAnd with some inspiration, maybe fill with periodic values and tile the output together to get a mosaic:\n\nusing Interpolations, ImageCore\nimgr = imrotate(img, π/4, fillvalue = Periodic())\nmosaicview([imgr for _ in 1:9]; nrow=3)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.imresize","page":"Package References","title":"ImageTransformations.imresize","text":"imresize(img, sz; [method]) -> imgr\nimresize(img, inds; [method]) -> imgr\nimresize(img; ratio, [method]) -> imgr\n\nupsample/downsample the image img to a given size sz or axes inds using interpolations. If ratio is provided, the output size is then ceil(Int, size(img).*ratio).\n\ntip: Tip\nThis interpolates the values at sub-pixel locations. If you are shrinking the image, you risk aliasing unless you low-pass filter img first.\n\nArguments\n\nimg: the input image array\nsz: the size of output array\ninds: the axes of output array If inds is passed, the output array imgr will be OffsetArray.\n\nParameters\n\ninfo: Info\nTo construct method, you may need to load Interpolations package first.\n\nratio: the upsample/downsample ratio used. The output size is ceil(Int, size(img).*ratio). If ratio is larger than 1, it is an upsample operation. Otherwise it is a downsample operation. ratio can also be a tuple, in which case ratio[i] specifies the resize ratio at dimension i.\nmethod::InterpolationType:  specify the interpolation method used for reconstruction. conveniently, methold can also be a Degree type, in which case a BSpline object will be created. For example, method = Linear() is equivalent to method = BSpline(Linear()).\n\nExamples\n\nusing ImageTransformations, TestImages, Interpolations\n\nimg = testimage(\"lighthouse\") # 512*768\n\n# pass integers as size\nimresize(img, 256, 384) # 256*384\nimresize(img, (256, 384)) # 256*384\nimresize(img, 256) # 256*768\n\n# pass indices as axes\nimresize(img, 1:256, 1:384) # 256*384\nimresize(img, (1:256, 1:384)) # 256*384\nimresize(img, (1:256, )) # 256*768\n\n# pass resize ratio\nimresize(img, ratio = 0.5) #256*384\nimresize(img, ratio = (2, 1)) # 1024*768\n\n# use different interpolation method\nimresize(img, (256, 384), method=Linear()) # 256*384 bilinear interpolation\nimresize(img, (256, 384), method=Lanczos4OpenCV()) # 256*384 OpenCV-compatible Lanczos 4 interpolation\n\nFor downsample with ratio=0.5, restrict is a much faster two-fold implementation that you can use.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Low-level-warping-API","page":"Package References","title":"Low-level warping API","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageTransformations.warp\nImageTransformations.WarpedView\nImageTransformations.InvWarpedView","category":"page"},{"location":"reference/#ImageTransformations.warp","page":"Package References","title":"ImageTransformations.warp","text":"warp(img, tform, [indices]; kwargs...) -> imgw\n\nTransform the coordinates of img, returning a new imgw satisfying imgw[I] = img[tform(I)].\n\nOutput\n\nThe output array imgw is an OffsetArray. Unless manually specified, axes(imgw) == axes(img) does not hold in general. If you just want a plain array, you can \"strip\" the custom indices with parent(imgw) or OffsetArrays.no_offset_view(imgw).\n\nArguments\n\nimg: the original image that you need coordinate transformation.\ntform: the coordinate transformation function or function-like object, it must accept a SVector as input. A useful package to create a wide variety of such transfomrations is CoordinateTransformations.jl.\nindices (Optional): specifies the output image axes. By default, the indices are computed in such a way that imgw contains all the original pixels in img using autorange. To do this inv(tform) has to be computed. If the given transfomration tform does not support inv then the parameter indices has to be specified manually.\n\nParameters\n\ninfo: Info\nTo construct method and fillvalue values, you may need to load Interpolations package first.\n\nmethod::Union{Degree, InterpolationType}: the interpolation method you want to use. By default it is BSpline(Linear()). To construct the method instance, one may need to load Interpolations.\nfillvalue: the value that used to fill the new region. The default value is NaN if possible, otherwise is 0. One can also pass the extrapolation boundary condition: Flat(), Reflect() and Periodic().\n\nSee also\n\nThere're some high-level interfaces of warp:\n\nimage rotation: imrotate\nimage resize: imresize\n\nThere are also lazy versions of warp:\n\nWarpedView is almost equivalent to warp except that it does not allocate memory.\nInvWarpedView(img, tform, [indices]; kwargs...) is almost equivalent to warp(img, inv(tform), [indices]; kwargs...) except that it does not allocate memory.\n\nExtended help\n\nParameters in detail\n\nThis approach is known as backward mode warping. It is called \"backward\" because the internal coordinate transformation is actually an inverse map from axes(imgr) to axes(img).\n\nYou can manually specify interpolation behavior by constructing AbstractExtrapolation object and passing it to warp as img. However, this is usually cumbersome. For this reason, there are two keywords method and fillvalue to conveniently construct an AbstractExtrapolation object during warp.\n\nwarning: Warning\nIf img is an AbstractExtrapolation, then additional method and fillvalue keywords will be discarded.\n\nmethod::Union{Degree, InterpolationType}\n\nThe interpolation method you want to use to reconstruct values in the wrapped image.\n\nAmong those possible InterpolationType choice, there are some commonly used methods that you may have used in other languages:\n\nnearest neighbor: BSpline(Constant())\ntriangle/bilinear: BSpline(Linear())\nbicubic: BSpline(Cubic(Line(OnGrid())))\nlanczos2: Lanczos(2)\nlanczos3: Lanczos(3)\nlanczos4: Lanczos(4) or Lanczos4OpenCV()\n\nWhen passing a Degree, it is expected to be a BSpline. For example, Linear() is equivalent to BSpline(Linear()).\n\nfillvalue\n\nIn case tform(I) maps to indices outside the original img, those locations are set to a value fillvalue. The default fillvalue is NaN if the element type of img supports it, and 0 otherwise.\n\nThe parameter fillvalue can be either a Number or Colorant. In this case, it will be converted to eltype(imgr) first. For example, fillvalue = 1 will be converted to Gray(1) which will fill the outside indices with white pixels.\n\nAlso, fillvalue can be extrapolation schemes: Flat(), Periodic() and Reflect(). The best way to understand these schemes is perhaps try it with small example:\n\nusing ImageTransformations, TestImages, Interpolations\nusing OffsetArrays: IdOffsetRange\n\nimg = testimage(\"lighthouse\")\n\nimgr = imrotate(img, π/4; fillvalue=Flat()) # zero extrapolation slope\nimgr = imrotate(img, π/4; fillvalue=Periodic()) # periodic boundary\nimgr = imrotate(img, π/4; fillvalue=Reflect()) # mirror boundary\n\naxes(imgr)\n\n# output\n\n(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837))\n\nThe meaning of the coordinates\n\nimgw keeps track of the indices that would result from applying inv(tform) to the indices of img. This can be very handy for keeping track of how pixels in imgw line up with pixels in img.\n\nusing ImageTransformations, TestImages, Interpolations\n\nimg = testimage(\"lighthouse\")\nimgr = imrotate(img, π/4)\nimgr_cropped = imrotate(img, π/4, axes(img))\n\n# No need to manually calculate the offsets\nimgr[axes(img)...] == imgr_cropped\n\n# output\ntrue\n\ntip: Tip\nFor performance consideration, it's recommended to pass the inds positional argument to warp instead of cropping the output with imgw[inds...].\n\nExamples: a 2d rotation\n\nnote: Note\nThis example only shows how to construct tform and calls warp. For common usage, it is recommended to use imrotate function directly.\n\nRotate around the center of img:\n\nusing ImageTransformations, CoordinateTransformations, Rotations, TestImages, OffsetArrays\nusing OffsetArrays: IdOffsetRange\nimg = testimage(\"lighthouse\") # axes (1:512, 1:768)\n\ntfm = recenter(RotMatrix(-pi/4), center(img))\nimgw = warp(img, tfm)\n\naxes(imgw)\n\n# output\n\n(IdOffsetRange(values=-196:709, indices=-196:709), IdOffsetRange(values=-68:837, indices=-68:837))\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageTransformations.WarpedView","page":"Package References","title":"ImageTransformations.WarpedView","text":"WarpedView(img, tform, [indices]; kwargs...) -> wv\n\nCreate a view of img that lazily transforms any given index I passed to wv[I] so that wv[I] == img[tform(I)].\n\nThis is the lazy view version of warp, please see warp for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ImageTransformations.InvWarpedView","page":"Package References","title":"ImageTransformations.InvWarpedView","text":"InvWarpedView(img, tinv, [indices]; kwargs...) -> wv\nInvWarpedView(inner_view, tinv) -> wv\n\nCreate a view of img that lazily transforms any given index I passed to wv[I] so that wv[I] == img[inv(tinv)(I)].\n\nExcept for the lazy evaluation, the following two lines are expected to be equivalent:\n\nwarp(img, inv(tform), [indices]; kwargs...)\ninvwarpedview(img, tform, [indices]; kwargs...)\n\nThe conceptual difference to WarpedView is that InvWarpedView is intended to be used when reasoning about the image is more convenient that reasoning about the indices. Furthermore, InvWarpedView allows simple nesting of transformations, in which case the transformations will be composed into a single one.\n\nFor detailed explaination of warp, associated arguments and parameters, please refer to warp.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Utilities","page":"Package References","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Package References","title":"Package References","text":"ImageTransformations.autorange","category":"page"},{"location":"reference/#ImageTransformations.autorange","page":"Package References","title":"ImageTransformations.autorange","text":"autorange(A::AbstractArray, tform::Transformation)\n\nFor given transformation tform, return the \"smallest\" range indices that preserves all information from A after applying tform.\n\nExamples\n\nFor transformation that preserves the array size, autorange is equivalent to axes(A).\n\nA = rand(5, 5)\ntform = IdentityTransformation()\nautorange(A, tform) == axes(A)\n\n# output\ntrue\n\nThe diffrence shows up when tform enlarges the input array A. In the following example, we need at least (0:6, 0:6) as the range indices to get all data of A:\n\nA = rand(5, 5)\ntform = recenter(RotMatrix(pi/8), center(A))\nautorange(A, tform)\n\n# output\n(0:6, 0:6)\n\nnote: Note\nThis function is not exported; it is mainly for internal usage to infer the default indices.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Operations","page":"Examples","title":"Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"grid-card-section\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"<div class=\"card grid-card\">\n<div class=\"grid-card-cover\">\n<div class=\"grid-card-description\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we illustrate how to construct a custom warping map and pass it to warp. This swirl example comes from the Princeton Computer Graphics course for Image Warping (Fall 2000) and scikit-image swirl example.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: card-cover-image)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n<div class=\"grid-card-text\">","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Swirl effect using warp operation","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>\n</div>","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"</div>","category":"page"},{"location":"#ImageTransformations.jl","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"using ImageShow","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"This package provides support for image resizing, image rotation, and other spatial transformations of arrays.","category":"page"},{"location":"#Overview","page":"ImageTransformations.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"ImageTransformations.jl consists of two sets of API: the low level warping operations, and the high-level operations that built on top of it.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Low-level warping API:\nwarp: backward-mode warping\nWarpedView: the lazy view version of warp\nInvWarpedView: the inverse of WarpedView\nhigh-level spatial operations:\nimresize: aspect adjustment\nrestrict: a much more efficient version of imresize that two-folds/down-samples image to approximate 1/2 size. (This is now provided by ImageBase.)\nimrotate: rotation","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"For detailed usage of these functions, please refer to function references and examples. The following section explains the core concept image warping so that you can get a clear understanding about this package while using it.","category":"page"},{"location":"#index_image_warping","page":"ImageTransformations.jl","title":"Image warping","text":"","category":"section"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"info: Info\nThis is just a very simple explaination on the internal of ImageTransformations. For more information about image warping, you can take a look at the Princeton Computer Graphics course for Image Warping (Fall 2000)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Most image spatial transformation operations (e.g., rotation, resizing, translation) fall into the category of warping operation. Mathematically, for given input image X, a (backward-mode) warping operation f consists of two functions: coordination map ϕ and intensity estimator τ.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Y_ij = f(X)_i j = τ(X ϕ(i j))","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"Take the following resizing operation as an example, for every pixel position p in output image Y, we 1) use the backward coordinate map ϕ to get its corresponding pixel position q in original image X. Since q may not be on grid, we need to 2) estimate the value of X on position q using function τ, and finally 3) assign X[q] back to Y[p]. In Julia words, it is","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"for p in CartesianIndices(Y)\n    q = ϕ(p) # backward coordinate map\n    v = τ(X, q) # estimate the value\n    Y[p] = v # assign value back\nend","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"As you may have notice, we use backward coordinate map because this is the simplest way to iterate every pixel of the output image. This is why it is called backward-mode warping. In some literature, it is also called reverse warping.","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"(Image: warp resize demo)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"In ImageTransformations, the warp-based operation uses Interpolations as our intensity estimator τ:","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"using Interpolations, ImageCore, TestImages\nusing ImageTransformations\n\nX = imresize(testimage(\"cameraman\"), (64, 64)) # use small image as an example\n\nsz = (128, 128)\nY = similar(X, sz...)\n\n# intensity estimator using interpolation\nitp = interpolate(X, BSpline(Linear())) # bilinear interpolation\nτ(q) = itp(q...)\n\n# A linear coordinate map that satisfies:\n#   - `ϕ(1, 1) == (1, 1)`\n#   - `ϕ(128, 128) == (64, 64)`\nK = (size(X) .- (1, 1))./(sz .- (1, 1))\nb = (1, 1) .- K\nϕ(p) = @. K*p + b\n\nfor p in CartesianIndices(Y)\n    q = ϕ(p.I)\n    Y[p] = τ(q)\nend\n\nmosaic(X, Y; nrow=1)","category":"page"},{"location":"","page":"ImageTransformations.jl","title":"ImageTransformations.jl","text":"This is the internal of ImageTransformations. For common usage of ImageTransformations, you should use either the low-level API warp or high-level API imresize and others.","category":"page"},{"location":"examples/operations/swirl/#Swirl-effect-using-warp-operation","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"","category":"section"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"(Image: Source code) (Image: notebook) (Image: Author) (Image: Update time)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"In this example, we illustrate how to construct a custom warping map and pass it to warp. This swirl example comes from the Princeton Computer Graphics course for Image Warping (Fall 2000) and scikit-image swirl example.","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"using ImageTransformations\nusing OffsetArrays, StaticArrays\nusing ImageShow, TestImages\nusing LinearAlgebra\n\nimg = imresize(testimage(\"cameraman\"), (256, 256));\nnothing #hide","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"As we've illustrated in image warping, a warp operation consists of two operations: backward coordinate map ϕ and intensity estimator. To implement swirl operation, we need to customize the coordinate map ϕ. A valid coordinate map q = ϕ(p) follows the following interface:","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"# SVector comes from StaticArrays\nϕ(::SVector{N})::SVector{N} where N","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"A cartesian position (x, y) can be transfered to/from polar coordinate (ρ, θ) using formula:","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"# Cartesian to Polar\nρ = norm(y-y0, x-x0)\nθ = atan(y/x)\n\n# Polar to Cartesian\ny = y0 + ρ*sin(θ)\nx = x0 + ρ*cos(θ)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"For given input index p, a swirl operation enforces more rotations in its polar coordinate using θ̃ = θ + ϕ + s*exp(-ρ/r), and returns the cartesian index (x̃, ỹ) from the warped polor coordinate (ρ, θ̃). (Here we use the formula from scikit-image swirl example to build our version.)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"function swirl(rotation, strength, radius)\n    x0 = OffsetArrays.center(img)\n    r = log(2)*radius/5\n\n    function swirl_map(x::SVector{N}) where N\n        xd = x .- x0\n        ρ = norm(xd)\n        θ = atan(reverse(xd)...)\n\n        # Note that `x == x0 .+ ρ .* reverse(sincos(θ))`\n        # swirl adds more rotations to θ based on the distance to center point\n        θ̃ = θ + rotation + strength * exp(-ρ/r)\n\n        SVector{N}(x0 .+ ρ .* reverse(sincos(θ̃)))\n    end\n\n    warp(img, swirl_map, axes(img))\nend","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"Now let's see how radius argument affects the result","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"preview = ImageShow.gif([swirl(0, 10, radius) for radius in 10:10:150]; fps=5)","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"","category":"page"},{"location":"examples/operations/swirl/","page":"Swirl effect using warp operation","title":"Swirl effect using warp operation","text":"This page was generated using DemoCards.jl and Literate.jl.","category":"page"}]
}
